setopt PROMPT_SUBST
#autoload colors && colors

init_prompt () {
	PROMPT="\$(left_prompt) "
	RPROMPT="\$(right_prompt)"
}

shortpath() {
    local fullpath="${$(pwd)/$HOME/~}"
    echo "Fullpath: $fullpath" >&2
    local IFS='/'
    # read -ra parts <<< "$fullpath"
    parts=("${(@s:/:)fullpath}")
    local shortpath=""
    # local part
    for part in "${parts[@]}"; do
        if [[ -n "$part" ]]; then
            if [[ "$part" == "~" ]]; then
                # Home directory
                shortpath+="~"

            elif [[ "$part" == "${parts[-1]}" ]]; then
                # Last part (current directory)
                shortpath+="/\033[1m${part}"

            else
                # Other parts
                shortpath+="/${part:0:1}"
            fi
        fi
    done

    if [[ -z "$shortpath" ]]; then
        shortpath="/"
    fi

    echo -e "\033[37m${shortpath}\033[0m"
}

left_prompt () {
  # local output=${${:-/${(j:/:)${(M)${(s:/:)${(D)PWD:h}}#(|.)[^.]}}/${PWD:t}}//\/~/\~}
  # echo %{$fg[white]%}$output%{$reset_color%}
  local output=$(shortpath)
  print $output
}

right_prompt () {
  output=($(zle_mode) $(git_status))
  print ${(j" ")output}
}


# [± branch-merging ruby-1.9.3-p125@nyx]
git_status () {
    local repo_status=""
    local repo_path="`git rev-parse --git-dir 2>/dev/null`"
    
    if [[ $repo_path != '' && $repo_path != '~' && $repo_path != "$HOME/.git" ]]; then
        if [[ $repo_path != "." && `git ls-files -m` != "" ]]; then
            # Dirty
            repo_status+="%{$fg[red]%}±%{$reset_color%} "
        else
            repo_status+="± "
        fi

        # branch
        repo_status+="%{$fg[white]%}`git symbolic-ref -q HEAD | sed 's/refs\/heads\///'`%{$reset_color%}"

        if [[ -e "$repo_path/BISECT_LOG" ]]; then
            repo_status+="+bisect"
        elif [[ -e "$repo_path/MERGE_HEAD" ]]; then
            repo_status+="+merge"
        elif [[ -e "$repo_path/rebase" || -e "$repo_path/rebase-apply" || -e "$repo_path/rebase-merge" || -e "$repo_path/../.dotest" ]]; then
            repo_status+="+rebase"
        fi
    fi

    echo $repo_status
}
# timestamp () {
#   echo "%*"
# }

# zle_mode () {
#     echo "$ZLE_MODE"
# }

# function zle-line-init zle-keymap-select {
#     case $KEYMAP in
#         vicmd) ZLE_MODE="COMMAND";; 
#         main) ZLE_MODE="";; # Should be using viins instead of main, but this works for now
#     esac
#     zle reset-prompt
# }

# ZLE_MODE=""
# zle -N zle-line-init
# zle -N zle-keymap-select

init_prompt
